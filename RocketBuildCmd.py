import sys
import getopt
import re


def CreateCmdFile( bOrigin, bLength, aOrigin, aLength, output ):

    fileName = re.search( r"[\\/]*(\w+\.\w+)\s*", output )

    fileString = """\
/******************************************************************************
 * %s
 * Generated by parseRocketMap.py, do not manually modify
 ******************************************************************************/

/* Output binary range */
ROMS
{
	BOOT_IMAGE: origin = 0x%s, length = 0x%s, romwidth = 16
	APP_IMAGE: origin = 0x%s, length = 0x%s, romwidth = 16
}
""" % (fileName.groups()[0], bOrigin, bLength, aOrigin, aLength)

    cmdFile = open( output, "w" )

    if cmdFile == None:
        print "Error creating file"
        sys.exit()

    cmdFile.write( fileString )
    cmdFile.close()
    

try: 
    opts, args = getopt.getopt( sys.argv[1:], "hm:o:", ["help", "map=", "out="])
except getopt.GetoptError, err:
    print str(err)
    sys.exit()

output = ""

for o, a in opts:
    if o in ("-h", "--help"):
        print """\
parseRocketMap.py
Usage:
    -h     help
    -m     map file to parse
              """
        sys.exit()

    elif o in ("-m", "--map="):

        print a
        mFile = open( a, "r").readlines()

        startAppImage = 0
        startBootImage = 0
        sizeAppImage = 0
        sizeBootImage = 0
        endAppImage = 0
        endBootImage = 0

        startBootSection = 0
        endBootSection = 0
        sizeBootSection = 0

        for line in mFile:

            if startAppImage == 0:
                match = re.match( r'([0-9a-fA-F]+)\s+_start_of_app_image', line )
                if match != None:
                    startAppImage = match.groups()[0]

            if startBootImage == 0:
                match = re.match( r'([0-9a-fA-F]+)\s+_start_of_boot_image', line )
                if match != None:
                    startBootImage = match.groups()[0]
            
            if endBootImage == 0:
                match = re.match( r'([0-9a-fA-F]+)\s+_end_of_boot_image', line )
                if match != None:
                    endBootImage = match.groups()[0]
            
            if endAppImage == 0:
                match = re.match( r'([0-9a-fA-F]+)\s+_end_of_app_image', line )
                if match != None:
                    endAppImage = match.groups()[0]

            if startBootSection == 0:
                match = re.match( r'([0-9a-fA-F]+)\s+_start_of_boot_sec', line )
                if match != None:
                    startBootSection = match.groups()[0]

            if endBootSection == 0:
                match = re.match( r'([0-9a-fA-F]+)\s+_end_of_boot_sec', line )
                if match != None:
                    endBootSection = match.groups()[0]

            #if sizeBoot == 0:
            #    match = re.match( r'([0-9a-fA-F]+)\s+_size_of_text_boot', line )
            #    if match != None:
            #        sizeBoot = match.groups()[0]
                    
    elif o in ("-o", "--out="):
        output = a
    
    
sizeBootImage = int(endBootImage,16) - int(startBootImage,16)
sizeAppImage = int(endAppImage,16) - int(startAppImage,16)
sizeBootSection = int(endBootSection,16) - int(startBootSection,16)

if sizeBootImage % 2 == 1:
    print "sizeBootImage not WORD aligned"
    sys.exit(-1)


if sizeAppImage % 2 == 1:
    print "sizeAppImage not WORD aligned"
    sys.exit(-1)


# Ensure that the BOOT image we are about to generate is no larger then half our
# available updateable flash
if sizeBootImage > (sizeBootSection/2):
    print "Error: boot image size must be <= half of the APP/BOOT flash section"
    print "boot image is %d bytes to large" % (sizeBootImage - (sizeBootSection/2))
    sys.exit(-1)

if output == "":
    print "no output file specified"
    sys.exit(-1)

sizeBootImage = "%04X" % (sizeBootImage)
sizeAppImage = "%04X" % (sizeAppImage)

CreateCmdFile( startBootImage, sizeBootImage, startAppImage, sizeAppImage, output )

sys.exit()


